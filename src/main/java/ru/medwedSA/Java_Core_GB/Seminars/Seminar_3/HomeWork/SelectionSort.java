/**
 *  Сортировка выбором -> сложность алгоритма O(n^2).
 *  Данная сортировка неустойчива, т.к. одинаковые элементы (с точки зрения той характеристики,
 *  по которой мы сортируем элементы) могут изменить своё положение.
 *  Хороший пример приведён в статье на Википедии:
 *  Покажем, почему данная реализация является неустойчивой.
 *  Рассмотрим следующий массив из элементов, каждый из которых имеет два поля. Сортировка идет по первому полю.
 *  Массив до сортировки:
 *  { (2, a), (2, b), (1, a) }
 *  Уже после первой итерации внешнего цикла будем иметь отсортированную последовательность:
 *  { (1, a), (2, b), (2, a) }
 *  Теперь заметим, что взаимное расположение элементов (2, a) и (2, b) изменилось.
 *  Таким образом, рассматриваемая реализация является неустойчивой.
 */

package ru.medwedSA.Java_Core_GB.Seminars.Seminar_3.HomeWork;

import java.util.Arrays;

public class SelectionSort {

    public static void main(String[] args) {

        int[] array = {10, 2, 10, 3, 1, 2, 5};
        System.out.println(Arrays.toString(array));

        selectionSort(array);
    }
/* https://commons.wikimedia.org/wiki/File:Selection-Sort-Animation.gif?uselang=ru#/media/ -> Файл:Selection-Sort-Animation.gif */
    private static void selectionSort(int[] array) { // Алгоритм сортировки принимает на вход только массив.
        for (int left = 0; left < array.length; left++) { // Начинаем движение по массиву с первого элемента.
	        int minInd = left; // Создаем переменную с номером текущего индекса.
	        for (int i = left; i < array.length; i++) { // Во втором цикле запускаем проход с элемента, с индексом
                                                        // из "верхнего" цикла.
		        if (array[i] < array[minInd]) { // Если элемент с текущим индексом из внутреннего цикла for меньше
                                                // элемента с индексом из внешнего цикла for, то...
			        minInd = i; // Запоминаем индекс меньшего элемента.
		        } // иначе идем до конца второго цикла for, в поисках меньшего элемента.
	        }
	        swap(array, left, minInd); // По завершении второго цикла for, в любом случае будет вызван
                                                  // метод swap(), в котором...
        }
        System.out.println(Arrays.toString(array)); // По завершению всех циклов вывод отсортированного массива
                                                       // в консоль.
    }

    private static void swap(int[] array, int index1, int index2) { // метод swap() -> меняет местами элементы относительно
                                                                // переданных в этот метод индексов.
        int tmp = array[index1];
        array[index1] = array[index2];
        array[index2] = tmp;
    }
}
