package ru.medwedSA.Java_Core_GB.Lectures.Lecture_1;

/*
 *  Присваивание:        =
 *  Арифметические:      *, /, +, -, %, ++, -- (++ инкремент, -- декремент)
 *  Операции сравнения:  <, >, ==, !=, <=, >=
 *  Логические операции: ||, &&, ^, !
 *  Побитовые операции:  <<, >>, &, |, ^
 */

public class LogicalOperationsJava {
    public static void main(String[] args) {
        int a = 123;
        a++; // инкремент.
        System.out.println(a); // 124

        int b = 123;
        System.out.println(b++); // казалось бы добавили инкремент, но получим значение 123 !!! (ПОСТФИКСНЫЙ
                                 // ИНКРЕМЕНТ)
        System.out.println(b); // НО при следующем вызове на печать получаем 124 !!!
                               // т.к. приоритет вызова операции инкремента в строке 17 НИЖЕ ЧЕМ ПРИОРИТЕТ вызова
                               // значения в консоль.
                               // И именно поэтому в строке 17 мы видим вначале вывод БЕЗ ИЗМЕНЕНИЙ, а уже в
                               // строке 19 вызов после инкремента.
        // Если изменить приоритет, то:
        int b1 = 123;
        System.out.println(++b1); // 124 -> операция инкремента приоритетнее операции печати в консоль.
                                  // (ПРЕФИКСНЫЙ ИНКРЕМЕНТ)
        boolean flag1 = 123 >= 345;
        System.out.println(flag1); // false
        boolean flag2 = 123 <= 888;
        System.out.println(flag2); // true
        boolean flag3 = 123 != 99;
        System.out.println(flag3); // true
        boolean flag4 = flag3 ^ flag2;
        System.out.println(flag4); // false

        // || -> конъюнкция
        // && -> дизъюнкция
        // ^ -> разделительная дизъюнкция
        // ! -> инверсия

        int l = 8;
        // 8 = 1000 -> двоичный код.
        // l = l << 1; // сдвигаем влево на 1 бит.
        System.out.println( l << 1 ); // получим в ответе число 16 или, 10000 в двоичном коде.
        int p = 18;
        //  18 = 10010 -> двоичный код.
        // p = p >> 1; // сдвигаем вправо на 1 бит.
        System.out.println( p >> 1 ); // получим в ответе число 9 или 1001 в двоичном коде.

        int n = 5;
        int m = 2;
        System.out.println( n | m ); // Ответ: 7. | -> побитовое ИЛИ, и считается в двоичном исполнении:
        // 101 -> 5
        // 010 -> 2
        // 111 -> 7
        int g = 6;
        int q = 3;
        System.out.println(g & q); // Ответ: 2. & -> побитовое И.
        // 110 -> 6
        // 011 -> 3
        // 010 -> 2
        int u = 7;
        int z = 4;
        System.out.println(u ^ z); // Ответ: 3. ^ -> побитовое РАЗДЕЛИТЕЛЬНОЕ ИЛИ.
        // 111 -> 7
        // 100 -> 4
        // 011 -> 3

        /*
         * То, что вложено в логику кода написанного ниже стоит послушать лектора. Лекция 1 с 52:30 (время. мин и сек)
         */
        String h = "unary"; // длинна 5, индекс 0...4
        boolean y = h.length() >= 5 && h.charAt(3) == 'r'; // true двойной знак && -> быстрая операция. Левую часть
                                                                // смотрит, а правую может и не смотреть.
        boolean c = h.length() >= 5 & h.charAt(3) == 'u'; // false
        System.out.println(y);
        System.out.println(c);

        int num = 123;
        num = num-- - --num;
        System.out.println(num); //Ответ 2. А почему? Понял прочитав тут -> https://skillbox.ru/media/base/inkrement_i_dekrement_v_java/

    }
}
